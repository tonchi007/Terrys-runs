<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rumpy Runner</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        canvas {
            display: block;
            background-color: black;
        }
    </style>
</head>
<body>
    <script>
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        document.body.appendChild(canvas);

        // Variables para escalar el juego
        let scale = 1; // Factor de escala para ajustar el juego al tamaño de la pantalla
        const baseWidth = 1920; // Ancho base del juego
        const baseHeight = 1080; // Alto base del juego

        // Función para ajustar el tamaño del canvas y escalar el juego
        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            // Calcular la escala en función del ancho o alto de la pantalla
            scale = Math.min(windowWidth / baseWidth, windowHeight / baseHeight);

            // Ajustar el tamaño del canvas
            canvas.width = baseWidth * scale;
            canvas.height = baseHeight * scale;

            // Ajustar la posición inicial del jugador y otros elementos
            player.y = canvas.height - 200 * scale;
            player.width = 150 * scale;
            player.height = 150 * scale;
            player.x = 100 * scale;
            player.jumpPower = -15 * scale;

            // Ajustar la posición de las nubes y el cartel
            decorativeImages.forEach(deco => {
                deco.y = 400 * scale; // Ajustar la posición vertical de las nubes
            });
            signY = 930 * scale; // Ajustar la posición vertical del cartel
        }

        // Ajustar el canvas al cargar la página y al cambiar el tamaño de la ventana
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        // Cargar imágenes del jugador
        const playerImages = ["RUMPI.png", "RUMPI2.png"].map(src => {
            const img = new Image();
            img.src = src;
            img.onload = () => {
                console.log(`Imagen cargada: ${src}`); // Depuración
                onImageLoad();
            };
            img.onerror = () => {
                console.error(`Error al cargar la imagen: ${src}`); // Depuración
            };
            return img;
        });
        let currentFrame = 0;
        let frameCounter = 0;

        // Cargar imágenes de obstáculos
        const obstacleImages = ["obstacle1.png", "obstacle2.png", "obstacle3.png"].map(src => {
            const img = new Image();
            img.src = src;
            img.onload = () => {
                console.log(`Imagen cargada: ${src}`); // Depuración
                onImageLoad();
            };
            img.onerror = () => {
                console.error(`Error al cargar la imagen: ${src}`); // Depuración
            };
            return img;
        });

        // Cargar imágenes decorativas (nubes)
        const decorativeImages = [
            { img: new Image(), x: canvas.width, y: 400, speed: 2 },
            { img: new Image(), x: canvas.width + 300, y: 550, speed: 3 },
            { img: new Image(), x: canvas.width + 600, y: 750, speed: 1.5 },
        ];
        decorativeImages.forEach((deco, index) => {
            deco.img.src = `./cloud${index + 1}.png`; // Asegúrate de tener imágenes como "cloud1.png", "cloud2.png", etc.
            deco.img.onload = () => {
                console.log(`Imagen cargada: cloud${index + 1}.png`); // Depuración
                onImageLoad();
            };
            deco.img.onerror = () => {
                console.error(`Error al cargar la imagen: cloud${index + 1}.png`); // Depuración
            };
        });

        // Cargar imagen del cartel decorativo
        const signImage = new Image();
        signImage.src = "./sign.png"; // Asegúrate de tener una imagen llamada "sign.png"
        signImage.onload = () => {
            console.log("Imagen cargada: sign.png"); // Depuración
            onImageLoad();
        };
        signImage.onerror = () => {
            console.error("Error al cargar la imagen: sign.png"); // Depuración
        };

        // Variables para controlar el cartel
        let signX = canvas.width; // Comienza fuera del canvas
        let signY = 930; // Posición vertical del cartel

        // Contador de imágenes cargadas
        let imagesLoaded = 0;
        const totalImages = playerImages.length + obstacleImages.length + decorativeImages.length + 1; // +1 para el cartel

        function onImageLoad() {
            imagesLoaded++;
            console.log(`Imágenes cargadas: ${imagesLoaded}/${totalImages}`); // Depuración
            if (imagesLoaded === totalImages) {
                console.log("Todas las imágenes cargadas. Iniciando juego..."); // Depuración
                gameLoop();
            }
        }

        // Variables del jugador
        let player = { 
            x: 100, 
            y: canvas.height - 200, 
            width: 150, 
            height: 150, 
            dy: 0, 
            gravity: 0.5, 
            jumpPower: -15, 
            grounded: false, 
            jumps: 0, 
            maxJumps: 2
        };

        let obstacles = [];
        let gameSpeed = 5;
        let score = 0;
        let isGameOver = false;
        let gameStarted = false;

        // Sonidos
        const jumpSound = new Audio('./jump.wav');
        const gameOverSound = new Audio('./gameover.wav');

        // Función para verificar colisiones
        function checkCollision(rect1, rect2) {
            const buffer = 20; // Reduce el área efectiva de colisión
            return (
                rect1.x + buffer < rect2.x + rect2.width - buffer &&
                rect1.x + rect1.width - buffer > rect2.x + buffer &&
                rect1.y + buffer < rect2.y + rect2.height - buffer &&
                rect1.y + rect1.height - buffer > rect2.y + buffer
            );
        }

        // Función para dibujar las nubes decorativas
        function drawDecorative() {
            decorativeImages.forEach(deco => {
                ctx.drawImage(deco.img, deco.x * scale, deco.y * scale, 100 * scale, 50 * scale); // Ajusta el tamaño según la escala
                deco.x -= deco.speed; // Mueve la imagen hacia la izquierda

                // Reiniciar la posición cuando la imagen salga del canvas
                if (deco.x + 100 * scale < 0) {
                    deco.x = canvas.width;
                    deco.y = Math.random() * (canvas.height / 2); // Cambia la posición vertical aleatoriamente
                }
            });
        }

        // Función para dibujar el cartel decorativo
        function drawSign() {
            ctx.drawImage(signImage, signX * scale, signY * scale, 150 * scale, 120 * scale); // Ajusta el tamaño según la escala
            signX -= gameSpeed; // Mueve el cartel hacia la izquierda a la velocidad del juego

            // Reiniciar la posición cuando el cartel salga del canvas
            if (signX + 150 * scale < 0) {
                signX = canvas.width;
            }
        }

        // Actualizar el estado del juego
        function update() {
            if (isGameOver || !gameStarted) return;
            
            if (score % 500 === 0 && score !== 0) {
                gameSpeed += 0.5;
            }
            
            player.y += player.dy;
            player.dy += player.gravity;
            if (player.y >= canvas.height - 200 * scale) {
                player.y = canvas.height - 200 * scale;
                player.dy = 0;
                player.grounded = true;
                player.jumps = 0;
            }

            if (Math.random() < 0.008) { // Obstáculos aparecen más espaciados
                let size = Math.random() * 100 + 50;
                let img = obstacleImages[Math.floor(Math.random() * obstacleImages.length)];
                obstacles.push({ x: canvas.width, y: canvas.height - size - 50, width: size, height: size, img: img });
            }
            
            obstacles.forEach(obstacle => obstacle.x -= gameSpeed);
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
            
            obstacles.forEach(obstacle => {
                if (checkCollision(player, obstacle)) {
                    isGameOver = true;
                    gameOverSound.play();
                }
            });
            
            frameCounter++;
            if (frameCounter % 5 === 0) {
                currentFrame = (currentFrame + 1) % playerImages.length;
            }
            
            score++;
        }

        // Dibujar el juego
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar las nubes decorativas
            drawDecorative();

            // Dibujar el cartel decorativo
            drawSign();

            // Dibujar la línea de suelo
            ctx.fillStyle = "white";
            ctx.fillRect(0, canvas.height - 60 * scale, canvas.width, 10 * scale);

            // Dibujar al jugador
            ctx.drawImage(playerImages[currentFrame], player.x * scale, player.y * scale, player.width * scale, player.height * scale);
            
            // Dibujar obstáculos
            obstacles.forEach(obstacle => {
                ctx.drawImage(obstacle.img, obstacle.x * scale, obstacle.y * scale, obstacle.width * scale, obstacle.height * scale);
            });
            
            // Dibujar la puntuación
            ctx.fillStyle = "white";
            ctx.font = `${30 * scale}px Arial`;
            ctx.fillText("Score: " + score, 100 * scale, 50 * scale);
            
            // Dibujar pantalla de Game Over
            if (isGameOver) {
                drawGameOver();
            }
        }

        // Dibujar pantalla de Game Over
        function drawGameOver() {
            ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = "white";
            ctx.font = `${50 * scale}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
            ctx.font = `${30 * scale}px Arial`;
            ctx.fillText("Score: " + score, canvas.width / 2, canvas.height / 2 + 50 * scale);
            ctx.fillText("Toca para reiniciar", canvas.width / 2, canvas.height / 2 + 100 * scale);
        }

        // Dibujar menú de inicio
        function drawStartMenu() {
            ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = "white";
            ctx.font = `${50 * scale}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText("Toca para comenzar", canvas.width / 2, canvas.height / 2);
        }

        // Bucle principal del juego
        function gameLoop() {
            if (!gameStarted) {
                drawStartMenu();
            } else {
                update();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        // Evento de toque para dispositivos móviles
        document.addEventListener("touchstart", (event) => {
            if (!gameStarted) {
                gameStarted = true;
            } else if (player.jumps < player.maxJumps) {
                player.dy = player.jumpPower;
                player.grounded = false;
                player.jumps++;
                jumpSound.play();
            }
            if (isGameOver) {
                document.location.reload();
            }
        });

        // Ajustar el tamaño del canvas al cambiar el tamaño de la ventana
        window.addEventListener("resize", resizeCanvas);
    </script>
</body>
</html>
